#!/usr/bin/env node
/*! @license ©2013 Ruben Verborgh - Multimedia Lab / iMinds / Ghent University */

var path = require('path'),
    http = require('http'),
    url = require('url'),
    querystring = require('querystring'),
    spawn = require('child_process').spawn,
    Negotiator = require('negotiator');
var clientPath = path.join(__dirname, 'ldf-client');

var MIME_JSON = 'application/json';
var MIME_TURTLE = 'text/turtle';
var MIME_PLAIN = 'text/plain';

// Retrieve and check arguments
var args = require('minimist')(process.argv.slice(2));
if (args._.length || args.help) {
  console.error('usage: ldf-client-http [-c config.json] [-p port]');
  return process.exit(1);
}
var configFile = args.c || path.join(__dirname, '../config-default.json'),
    port = parseInt(args.p, 10) || 3000;

var availableMimeTypes = [];

getMimeTypes(function (types) {
  availableMimeTypes = types;

  // Start server
  var server = http.createServer(handleRequest);
  server.listen(port);
  console.error('Server running on http://localhost:' + port + '/');
});

// Retrieves supported result mimeTypes by the client
function getMimeTypes(callback) {
  var client = spawn(process.argv[0], [clientPath, '--listformats'],
                     { stdio: ['ignore', 'pipe', 'pipe'] });
  var data = '';

  // Write a successful data response
  client.stdout.setEncoding('utf8');
  client.stdout.on('data', function (type) {
    data += type;
  });
  client.stdout.once('end', function () {
    callback(data.trim().split('\n'));
  });
}

// Handles an HTTP request
function handleRequest(request, response) {
  // Verify the path
  var requestUrl = url.parse(request.url, true);
  if (requestUrl.pathname !== '/sparql') {
    response.writeHead(404, { 'content-type': MIME_JSON });
    response.end(JSON.stringify({ message: 'Resource not found' }));
    return;
  }

  // Parse the query, depending on the HTTP method
  switch (request.method) {
  case 'POST':
    return parseBody(request, function (query) { writeQueryResult(request, response, query); });
  case 'GET':
    return writeQueryResult(request, response, requestUrl.query.query || '');
  default:
    response.writeHead(405, { 'content-type': MIME_PLAIN });
    response.end();
  }
}

// Writes the result of the given SPARQL query
function writeQueryResult(request, response, query) {
  // Get the results of the query from the client
  var mimeType = new Negotiator(request).mediaType(availableMimeTypes),
      client = spawn(process.argv[0], [clientPath, '-q', query, '-c', configFile, '-t', mimeType],
                     { stdio: ['ignore', 'pipe', 'pipe'] });

  // Write a successful data response
  client.stdout.setEncoding('utf8');
  client.stdout.once('data', function (data) {
    if (!response.headersSent) {
      response.writeHead(200, { 'content-type': mimeType });
      response.write(data);
      client.stdout.pipe(response);
    }
  });

  // Write an error response
  client.stderr.setEncoding('utf8');
  client.stderr.once('data', function (data) {
    if (!response.headersSent) {
      response.writeHead(400, { 'content-type': MIME_PLAIN });
      response.write(data);
      client.stderr.pipe(response);
    }
  });

  // End the response if all streams have ended
  var ended = false;
  client.stdout.on('end', function () { ended ? response.end() : ended = true; });
  client.stderr.on('end', function () { ended ? response.end() : ended = true; });

  // Stop the client if the connection is terminated
  response.on('close', function () { client.kill('SIGKILL'); });
}

// Parses the body of a SPARQL POST request
function parseBody(request, callback) {
  var body = '';
  request.setEncoding('utf8');
  request.on('data', function (chunk) { body += chunk; });
  request.on('end', function () {
    switch (request.headers['content-type']) {
    case 'application/sparql-query':
      return callback(body);
    case 'application/x-www-form-urlencoded':
      return callback(querystring.parse(body).query || '');
    default:
      return callback('');
    }
  });
}
